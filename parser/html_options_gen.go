// Auto-generated by internal/cmd/genoptions/genoptions.go -- DO NOT EDIT!
package parser

import "github.com/lestrrat-go/option"

type HTMLParseOption interface {
	option.Interface
	htmlParseOption()
}

type nativeHTMLParseOption struct {
	option.Interface
	enabled bool
}

func (*nativeHTMLParseOption) parseOption()     {}
func (*nativeHTMLParseOption) htmlParseOption() {}
func (o *nativeHTMLParseOption) Enabled() bool {
	return o.enabled
}

type optkeyWithHTMLParseRecover struct{}
type optkeyWithHTMLParseNoDefDTD struct{}
type optkeyWithHTMLParseNoError struct{}
type optkeyWithHTMLParseNoWarning struct{}
type optkeyWithHTMLParsePedantic struct{}
type optkeyWithHTMLParseNoBlanks struct{}
type optkeyWithHTMLParseNoNet struct{}
type optkeyWithHTMLParseNoImplied struct{}
type optkeyWithHTMLParseCompact struct{}
type optkeyWithHTMLParseIgnoreEnc struct{}

// actual values for each of the flags
const (
	optvalWithHTMLParseRecover   = 1 << 0
	optvalWithHTMLParseNoDefDTD  = 1 << 2
	optvalWithHTMLParseNoError   = 1 << 5
	optvalWithHTMLParseNoWarning = 1 << 6
	optvalWithHTMLParsePedantic  = 1 << 7
	optvalWithHTMLParseNoBlanks  = 1 << 8
	optvalWithHTMLParseNoNet     = 1 << 11
	optvalWithHTMLParseNoImplied = 1 << 13
	optvalWithHTMLParseCompact   = 1 << 16
	optvalWithHTMLParseIgnoreEnc = 1 << 21
)

// WithHTMLParseRecover specifies if the parser should enable relaxed parsing
func WithHTMLParseRecover(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseRecover{}, optvalWithHTMLParseRecover),
	}
}

// WithHTMLParseNoDefDTD specifies if the parser should disable using a default doctype when absent
func WithHTMLParseNoDefDTD(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoDefDTD{}, optvalWithHTMLParseNoDefDTD),
	}
}

// WithHTMLParseNoError specifies if the parser should suppress error reports
func WithHTMLParseNoError(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoError{}, optvalWithHTMLParseNoError),
	}
}

// WithHTMLParseNoWarning specifies if the parser should suppress warnings reports
func WithHTMLParseNoWarning(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoWarning{}, optvalWithHTMLParseNoWarning),
	}
}

// WithHTMLParsePedantic specifies if the parser should enable pedantic error reporting
func WithHTMLParsePedantic(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParsePedantic{}, optvalWithHTMLParsePedantic),
	}
}

// WithHTMLParseNoBlanks specifies if the parser should removes blank nodes
func WithHTMLParseNoBlanks(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoBlanks{}, optvalWithHTMLParseNoBlanks),
	}
}

// WithHTMLParseNoNet specifies if the parser should forbid network access during parsing
func WithHTMLParseNoNet(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoNet{}, optvalWithHTMLParseNoNet),
	}
}

// WithHTMLParseNoImplied specifies if the parser should disable implied html/body elements
func WithHTMLParseNoImplied(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseNoImplied{}, optvalWithHTMLParseNoImplied),
	}
}

// WithHTMLParseCompact specifies if the parser should enable compaction of small text nodes
func WithHTMLParseCompact(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseCompact{}, optvalWithHTMLParseCompact),
	}
}

// WithHTMLParseIgnoreEnc specifies if the parser should ignore internal document encoding hints
func WithHTMLParseIgnoreEnc(b bool) HTMLParseOption {
	return &nativeHTMLParseOption{
		enabled:   b,
		Interface: option.New(optkeyWithHTMLParseIgnoreEnc{}, optvalWithHTMLParseIgnoreEnc),
	}
}

func HTMLOptionsToFlag(options ...HTMLParseOption) int {
	var flag int
	for _, rawopt := range options {
		option, ok := rawopt.(*nativeHTMLParseOption)
		if !ok {
			continue
		}
		var toggle bool
		if option.Enabled() {
			toggle = (flag & option.Value().(int)) == 1
		} else {
			toggle = (flag & option.Value().(int)) == 0
		}
		if toggle {
			flag ^= option.Value().(int)
		}
	}
	return flag
}
