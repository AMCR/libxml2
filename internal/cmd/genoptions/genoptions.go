package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/lestrrat-go/codegen"
	"github.com/pkg/errors"
)

func main() {
	if err := _main(); err != nil {
		//nolint:forbidigo
		fmt.Printf("%s\n", err.Error())
		os.Exit(1)
	}
}

func _main() error {
	if err := genXMLParseOptions(); err != nil {
		return err
	}
	if err := genHTMLParseOptions(); err != nil {
		return err
	}
	return nil
}

type optiondef struct {
	name          string
	description   string
	explicitShift bool
	shift         int
}

//nolint:unparam
func genInterface(dst io.Writer, mltyp string, options ...*optiondef) error {
	fmt.Fprintf(dst, "\n// Auto-generated by internal/cmd/genoptions/genoptions.go -- DO NOT EDIT!")
	fmt.Fprintf(dst, "\npackage parser")
	fmt.Fprintf(dst, "\nimport \"github.com/lestrrat-go/option\"")

	fmt.Fprintf(dst, "\n\ntype %sParseOption interface {", strings.ToUpper(mltyp))
	fmt.Fprintf(dst, "\noption.Interface")
	fmt.Fprintf(dst, "\n%sParseOption()", mltyp)
	fmt.Fprintf(dst, "\n}")
	fmt.Fprintf(dst, "\n\ntype native%sParseOption struct {", strings.ToUpper(mltyp))
	fmt.Fprintf(dst, "\noption.Interface")
	fmt.Fprintf(dst, "\nenabled bool")
	fmt.Fprintf(dst, "\n}")
	fmt.Fprintf(dst, "\nfunc (*native%sParseOption) %sParseOption() {}", strings.ToUpper(mltyp), mltyp)
	fmt.Fprintf(dst, "\nfunc (o *native%sParseOption) Enabled() bool {", strings.ToUpper(mltyp))
	fmt.Fprintf(dst, "\nreturn o.enabled")
	fmt.Fprintf(dst, "\n}")

	var keySection bytes.Buffer
	var valueSection bytes.Buffer
	var bodySection bytes.Buffer

	fmt.Fprintf(&valueSection, "\n// actual values for each of the flags")
	fmt.Fprintf(&valueSection, "\nconst (")
	for i, option := range options {
		optname := fmt.Sprintf(`With%sParse%s`, strings.ToUpper(mltyp), option.name)

		fmt.Fprintf(&keySection, "\ntype optkey%[1]s struct{}", optname)

		if option.explicitShift {
			fmt.Fprintf(&valueSection, "\noptval%s = 1<<%d", optname, option.shift)
		} else {
			if i == 0 {
				fmt.Fprintf(&valueSection, "\noptval%s = iota << 1", optname)
			} else {
				fmt.Fprintf(&valueSection, "\noptval%s", optname)
			}
		}

		fmt.Fprintf(&bodySection, "\n\n// %s specifies if the parser should %s", optname, option.description)
		fmt.Fprintf(&bodySection, "\nfunc %s(b bool) %sParseOption {", optname, strings.ToUpper(mltyp))
		fmt.Fprintf(&bodySection, "\nreturn &native%sParseOption{", strings.ToUpper(mltyp))
		fmt.Fprintf(&bodySection, "\nenabled: b,")
		fmt.Fprintf(&bodySection, "\nInterface: option.New(optkey%[1]s{}, optval%[1]s),", optname)
		fmt.Fprintf(&bodySection, "\n}")
		fmt.Fprintf(&bodySection, "\n}")
	}

	fmt.Fprintf(&bodySection, "\n\nfunc %[1]sOptionsToFlag(options ...%[1]sParseOption) int {", strings.ToUpper(mltyp))
	fmt.Fprintf(&bodySection, "\nvar flag int")
	fmt.Fprintf(&bodySection, "\nfor _, rawopt := range options {")
	fmt.Fprintf(&bodySection, "\noption, ok := rawopt.(*native%sParseOption)", strings.ToUpper(mltyp))
	fmt.Fprintf(&bodySection, "\nif !ok {")
	fmt.Fprintf(&bodySection, "\ncontinue")
	fmt.Fprintf(&bodySection, "\n}")
	fmt.Fprintf(&bodySection, "\nif option.Enabled() {")
	fmt.Fprintf(&bodySection, "\nflag |= option.Value().(int)")
	fmt.Fprintf(&bodySection, "\n} else {")
	fmt.Fprintf(&bodySection, "\nflag &= ^(option.Value().(int))")
	fmt.Fprintf(&bodySection, "\n}")
	fmt.Fprintf(&bodySection, "\n}")
	fmt.Fprintf(&bodySection, "\nreturn flag")
	fmt.Fprintf(&bodySection, "\n}")

	fmt.Fprintf(&valueSection, "\n)")

	_, _ = keySection.WriteTo(dst)
	_, _ = valueSection.WriteTo(dst)
	_, _ = bodySection.WriteTo(dst)

	return nil
}

// Generate options in the form WithXXXX that match the parser options
func genXMLParseOptions() error {
	var options = []*optiondef{
		// The order matters! DON'T MOVE!
		{
			name:        "Recover",
			description: "recover on errors",
		},
		{
			name:        "NoEnt",
			description: "substitute entities",
		},
		{
			name:        "DTDLoad",
			description: "load the external subset",
		},
		{
			name:        "DTDAttr",
			description: "use default DTD attributes",
		},
		{
			name:        "DTDValid",
			description: "validate with the DTD",
		},
		{
			name:        "NoError",
			description: "suppress error reports",
		},
		{
			name:        "NoWarning",
			description: "suppress warning reports",
		},
		{
			name:        "Pedantic",
			description: "use pedantic error reporting",
		},
		{
			name:        "NoBlanks",
			description: "remove blank nodes",
		},
		{
			name:        "SAX1",
			description: "use the SAX1 interface internally",
		},
		{
			name:        "XInclude",
			description: "implement XInclude substitution",
		},
		{
			name:        "NoNet",
			description: "forbid network access",
		},
		{
			name:        "NoDict",
			description: "avoid reusing the context dictionary",
		},
		{
			name:        "Nsclean",
			description: "remove redundant namespace declarations",
		},
		{
			name:        "NoCDATA",
			description: "merge CDATA as text nodes",
		},
		{
			name:        "NoXIncNode",
			description: "avoid generating XINCLUDE START/END nodes",
		},
		{
			name:        "Compact",
			description: "compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)",
		},
		{
			name:        "Old10",
			description: "parse using XML-1.0 before update 5",
		},
		{
			name:        "NoBaseFix",
			description: "avoid fixing up XINCLUDE xml:base uris",
		},
		{
			name:        "Huge",
			description: "relax any hrdcoded limit from the parser",
		},
		{
			name:        "OldSAX",
			description: "parse using SAX2 interface before 2.7.0",
		},
		{
			name:        "IgnoreEnc",
			description: "ignore internal document encoding hints",
		},
		{
			name:        "BigLines",
			description: "store big line numbers in text PSVI field",
		},
	}

	var buf bytes.Buffer
	if err := genInterface(&buf, "xml", options...); err != nil {
		return errors.Wrap(err, `failed to generate itnerface`)
	}

	srcbytes := buf.Bytes() // save so we can use in error reporting later
	if err := codegen.WriteFile("parser/xml_options_gen.go", &buf, codegen.WithFormatCode(true)); err != nil {
		_ = codegen.Write(os.Stdout, bytes.NewReader(srcbytes), codegen.WithLineNumber(true))
		return errors.Wrap(err, `failed to format code`)
	}
	return nil
}

func genHTMLParseOptions() error {
	var options = []*optiondef{
		// The order matters! DON'T MOVE!
		{
			name:        "Recover",
			description: "enable relaxed parsing",
		},
		{
			name:        "NoDefDTD",
			description: "disable using a default doctype when absent",
			shift:       2,
		},
		{
			name:        "NoError",
			description: "suppress error reports",
			shift:       5,
		},
		{
			name:        "NoWarning",
			description: "suppress warnings reports",
			shift:       6,
		},
		{
			name:        "Pedantic",
			description: "enable pedantic error reporting",
			shift:       7,
		},
		{
			name:        "NoBlanks",
			description: "removes blank nodes",
			shift:       8,
		},
		{
			name:        "NoNet",
			description: "forbid network access during parsing",
			shift:       11,
		},
		{
			name:        "NoImplied",
			description: "disable implied html/body elements",
			shift:       13,
		},
		{
			name:        "Compact",
			description: "enable compaction of small text nodes",
			shift:       16,
		},
		{
			name:        "IgnoreEnc",
			description: "ignore internal document encoding hints",
			shift:       21,
		},
	}

	for _, option := range options {
		option.explicitShift = true
	}
	var buf bytes.Buffer
	if err := genInterface(&buf, "html", options...); err != nil {
		return errors.Wrap(err, `failed to generate itnerface`)
	}

	srcbytes := buf.Bytes() // save so we can use in error reporting later
	if err := codegen.WriteFile("parser/html_options_gen.go", &buf, codegen.WithFormatCode(true)); err != nil {
		_ = codegen.Write(os.Stdout, bytes.NewReader(srcbytes), codegen.WithLineNumber(true))
		return errors.Wrap(err, `failed to format code`)
	}
	return nil
}
